#!/usr/bin/env python
"""
Obtain cDNA alignments from an Ensembl database.
"""
from __future__ import print_function
import icedbProgSetup  # noqa: F401
import sys
import argparse
from pycbio.hgdata import hgDb
from pycbio.hgdata.psl import Psl, PslBlock, reverseCoords
from pycbio.hgdata.cigar import ExonerateCigar, OP_ALIGNED, OP_TINSERT, OP_TDELETE

from pycbio.sys import dbOps
from pycbio.ncbi.assembly import AssemblyReport
import eutils.client
import MySQLdb
import MySQLdb.cursors

ensDbHost = "ensembldb.ensembl.org"
ensDbPort = 5306
ensDbUser = "anonymous"

verbose = False

def parseArgs():
    desc = """Fetch cDNA alignments from Ensembl and load as PSLs in evidence
    sqllite3 database.

    The Ensembl alignments don't include the poly-A and lack the lengths,
    The length of cDNA sequences are obtained from either the UCSC browser
    database or NCBI eutils API.
"""
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('--hgFixedDb', default="hgFixed",
                        help="""hgFixed database to use to get sizes""")
    parser.add_argument('--limit', type=int,
                        help="""limit on query resuts, used for tests""")
    parser.add_argument('--verbose', action="store_true", default=False,
                        help="""verbose tracing""")
    parser.add_argument('ensemblCDnaDb',
                        help="""Ensembl cDNA database to use""")
    parser.add_argument('assemblyReport',
                        help="""NCBI assembly report for mapping chromosome names""")
    parser.add_argument('pslOut',
                        help="""PSL of alignments""")
    opts = parser.parse_args()
    global verbose
    verbose = opts.verbose
    return opts

ensCDnaAlnQuery = """SELECT
    daf.hit_name, daf.hit_strand, daf.hit_start, daf.hit_end,
    sr.name, sr.length, daf.seq_region_strand, daf.seq_region_start, daf.seq_region_end,
    daf.cigar_line
  FROM
    dna_align_feature daf, seq_region sr, external_db ed, transcript_supporting_feature tsf
  WHERE
    ((daf.seq_region_id = sr.seq_region_id)
     AND (daf.external_db_id = ed.external_db_id)
     AND (ed.db_name = "EMBL")
     AND (daf.dna_align_feature_id = tsf.feature_id)
     AND (tsf.feature_type = "dna_align_feature"))"""


class CDnaSizeFinder(object):
    "work around the fact that Ensembl doesn't have cDNA sizes"
    def __init__(self, hgFixedDb):
        self.hgFixedConn = hgDb.connect(hgFixedDb)
        self.eclient = eutils.client.Client()

    def __getSizeUcsc(self, accver):
        acc, ver = accver.split('.')
        cur = self.hgFixedConn.cursor()
        try:
            sql = """select size from gbSeq where (acc = %s) and (version = %s)"""
            cur.execute(sql, (acc, int(ver)))
            row = cur.fetchone()
            if row is None:
                return None
            else:
                return row[0]
        finally:
            cur.close()

    def __getSizeEutils(self, accver):
        esr = self.eclient.esearch(db='nuccore', term=accver)
        if len(esr.ids) == 0:
            return None
        if len(esr.ids) > 1:
            raise Exception("multiple results return for eutil query for `{}'".format(accver))
        efr = self.eclient.efetch(db='nuccore', id=esr.ids[0])
        return efr.gbseqs[0].length

    def getSize(self, accver):
        size = self.__getSizeUcsc(accver)
        if size is None:
            size = self.__getSizeEutils(accver)
        return size


def ensemblCDnaQuery(ensemblCDnaDb, limit=None):
    "generator of cDNA alignments from Ensembl"
    conn = MySQLdb.Connect(host=ensDbHost, port=ensDbPort, user=ensDbUser,
                           db=ensemblCDnaDb, cursorclass=MySQLdb.cursors.DictCursor)
    sql = ensCDnaAlnQuery
    if limit is not None:
        sql += " LIMIT {}".format(limit)
    try:
        cur = conn.cursor()
        cur.execute(sql)
        for row in cur:
            yield row
    finally:
        conn.close()


def processCigarMatch(psl, size, qNext, tNext):
    blk = PslBlock(psl, qNext, tNext, size)
    psl.blocks.append(blk)
    psl.blockCount += 1
    psl.match += size
    return (qNext + size, tNext + size)


def processCigarInsert(psl, size, tNext):
    psl.tNumInsert += 1
    psl.tBaseInsert += size
    return tNext + size


def processCigarDelete(psl, size, qNext):
    psl.qNumInsert += 1
    psl.qBaseInsert += size
    return qNext + size


def pslFromCigar(qName, qSize, qStart, qEnd, qStrand, tName, tSize, tStart, tEnd, tStrand, cigarStr):
    "create a PSL from an Ensembl-style cigar formatted alignment"
    cigar = ExonerateCigar(cigarStr)
    psl = Psl()
    psl.qName = qName
    psl.qSize = qSize
    psl.qStart = qStart
    psl.qEnd = qEnd
    psl.tName = tName
    psl.tSize = tSize
    psl.tStart = tStart
    psl.tEnd = tEnd
    psl.strand = qStrand + tStrand

    qNext = qStart
    qBlkEnd = qEnd
    if qStrand == '-':
        qNext, qBlkEnd = reverseCoords(qNext, qBlkEnd, qSize)
    tNext = tStart
    tBlkEnd = tEnd
    if tStrand == '-':
        tNext, tBlkEnd = reverseCoords(tNext, tBlkEnd, tSize)

    for op in cigar:
        if op.code == OP_ALIGNED:
            qNext, tNext = processCigarMatch(psl, op.count, qNext, tNext)
        elif op.code == OP_TINSERT:
            tNext = processCigarInsert(psl, op.count, tNext)
        elif op.code == OP_TDELETE:
            qNext = processCigarDelete(psl, op.count, qNext)
        else:
            raise Exception("invalid CIGAR op {} in {}".format(op, cigar))

    if qNext != qBlkEnd:
        raise Exception("CIGAR length does not match aligned query range: {} {}".format(qName, cigar))
    if tNext != tBlkEnd:
        raise Exception("CIGAR length does not match aligned target range: {} {}".format(qName, cigar))
    assert(len(psl.blocks) == psl.blockCount)
    if psl.getTStrand() == '-':
        psl = psl.reverseComplement()
    psl.strand = psl.strand[0]   # BLAT convention
    return psl


def orientToStrand(orient):
    return '-' if orient < 0 else '+'


def pslFromEnsembl(row, qSize, tName, tSize):
    return pslFromCigar(row["hit_name"], qSize, row["hit_start"] - 1,  row["hit_end"], orientToStrand(row["hit_strand"]),
                        tName, tSize, row["seq_region_start"] - 1, row["seq_region_end"], orientToStrand(row["seq_region_strand"]),
                        row["cigar_line"])


def convertToPsl(row, cDnaSizeFinder, asmReport):
    "return psl or None"
    qSize = cDnaSizeFinder.getSize(row["hit_name"])
    if qSize is None:
        print("Note: UCSC and eutils esearch can't find `{}'".format(row["hit_name"]), file=sys.stderr)
        return None
    # unplaced use GenBank acccession
    chromInfo = asmReport.bySequenceName.get(row["name"])
    if chromInfo is None:
        chromInfo = asmReport.byGenBankAccn.get(row["name"])
    if chromInfo is None:
        print("Note: Ensembl chromosome `{}' not in assembly info".format(row["name"]), file=sys.stderr)
        return None
    if chromInfo.ucscStyleName is None:
        print("Note: Ensembl chromosome `{}' is not mapped to an UCSC chromosome".format(row["name"]), file=sys.stderr)
        return None
    return pslFromEnsembl(row, qSize, chromInfo.ucscStyleName, chromInfo.sequenceLength)


def ensemblCDnaToPsl(ensemblCDnaDb, limit, cDnaSizeFinder, asmReport, pslOutFh):
    for row in ensemblCDnaQuery(ensemblCDnaDb, limit):
        if verbose:
            print(row, file=sys.stderr)
        psl = convertToPsl(row, cDnaSizeFinder, asmReport)
        if psl is not None:
            psl.write(pslOutFh)


def cdnaEnsemblAligns(opts):
    "main function"
    cDnaSizeFinder = CDnaSizeFinder(opts.hgFixedDb)
    asmReport = AssemblyReport(opts.assemblyReport)
    with open(opts.pslOut, "w") as pslOutFh:
        ensemblCDnaToPsl(opts.ensemblCDnaDb, opts.limit, cDnaSizeFinder, asmReport, pslOutFh),

dbOps.mySqlSetErrorOnWarn()
cdnaEnsemblAligns(parseArgs())
