#!/usr/bin/env python

from __future__ import print_function
import sys
import os
import argparse
from shutil import copyfile
sys.path.insert(0, os.path.expanduser("~markd/compbio/code/pycbio"))
myBinDir = os.path.normpath(os.path.dirname(sys.argv[0]))
sys.path.append(myBinDir + "/../lib")
from pycbio.sys import fileOps
from gencode_icedb import dataOps, pipelineOps

verbose = False
def parseArgs():
    desc = """Estimate the read length to use in building the index.  This does
    a partial scan of the read file"""
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('--sampleSize', type=int, default=20000,
                        help="number of reads to examine, if zero, examine all")
    parser.add_argument('--verbose', action="store_true", default=False,
                        help="write verbose output")
    parser.add_argument('readsFile',
                        help="""input reads in SAM, BAM or Fastq format, which maybe compressed""")
    parser.add_argument('outfile', default=None, nargs='?',
                        help="""write length to this file, defaults to stdout""")
    opts = parser.parse_args()
    if opts.sampleSize <= 0:
        opts.sampleSize = sys.maxint
    verbose = opts.verbose
    return opts

def fastqReader(readsFile):
    return pipelineOps.openPipeline(dataOps.getReadsCatCommand(readsFile), verbose=verbose)

def fastqReadSeq(fqfh):
    """read one  fastq sequence or None on EOF"""
    # advance to `@' line
    lines = [fqfh.readline() for i in xrange(4)]
    if len(lines[0]) == 0:
        return None
    if len(lines[1]) == 0:
        raise Exception("premature EOF in FASTQ record")
    return lines[1].strip()

def fastqGenerator(fqfh):
    """read of fastq sequences. only sequence string is returned"""
    while True:
        seq = fastqReadSeq(fqfh)
        if seq == None:
            break
        else:
            yield seq

def collectReadLens(readsFile, sampleSize):
    readCnt = 0
    totalLen = 0
    fqfh = fastqReader(readsFile)
    for seq in fastqGenerator(fqfh):
        readCnt += 1
        totalLen += len(seq)
        if readCnt >= sampleSize:
            break
    fqfh.close()
    return (readCnt, totalLen)

def writeReadLen(fh, aveLen):
    fh.write(str(aveLen)+'\n')

def estimateReadLength(opts):
    readCnt, totalLen = collectReadLens(opts.readsFile, opts.sampleSize)
    if readCnt == 0:
        raise Exception("no reads found in " + opts.readsFile)
    aveLen = totalLen / readCnt
    if aveLen == 0:
        raise Exception("aver length of 0 from " + opts.readsFile)
    if opts.outfile == None:
        writeReadLen(sys.stdout, aveLen)
    else:
        with open(opts.outfile, "w") as fh:
            writeReadLen(fh, aveLen)

estimateReadLength(parseArgs())
