#!/usr/bin/env python

from __future__ import print_function
import icedbProgSetup  # noqa: F401
import sys
import argparse
from gencode_icedb import dataOps
from pycbio.sys import loggingOps
import pipettor
import logging


def parseArgs():
    desc = """Estimate the read length to use in building the index.  This does
    a partial scan of the read file"""
    parser = argparse.ArgumentParser(description=desc)
    loggingOps.addCmdOptions(parser)
    parser.add_argument('--sampleSize', type=int, default=20000,
                        help="number of reads to examine, if zero, examine all")
    parser.add_argument('readsFile',
                        help="""input reads in SAM, BAM or Fastq format, which maybe compressed""")
    parser.add_argument('outfile', default=None, nargs='?',
                        help="""write length to this file, defaults to stdout""")
    opts = parser.parse_args()
    if opts.sampleSize <= 0:
        opts.sampleSize = sys.maxint
    loggingOps.setupFromCmd(opts, sys.argv[0])
    return opts


def fastqReader(readsFile):
    return pipettor.Popen(dataOps.getReadsCatCommand(readsFile), logger=logging.getLogger())


def fastqReadSeq(fqfh):
    """read one  fastq sequence or None on EOF"""
    # advance to `@' line
    lines = [fqfh.readline() for i in xrange(4)]
    if len(lines[0]) == 0:
        return None
    if len(lines[1]) == 0:
        raise Exception("premature EOF in FASTQ record")
    return lines[1].strip()


def fastqGenerator(fqfh):
    """read of fastq sequences. only sequence string is returned"""
    while True:
        seq = fastqReadSeq(fqfh)
        if seq is None:
            break
        else:
            yield seq


def collectReadLens(readsFile, sampleSize):
    readCnt = 0
    totalLen = 0
    fqfh = fastqReader(readsFile)
    for seq in fastqGenerator(fqfh):
        readCnt += 1
        totalLen += len(seq)
        if readCnt >= sampleSize:
            break
    fqfh.close()
    return (readCnt, totalLen)


def writeReadLen(fh, aveLen):
    fh.write('{}\n'.format(aveLen))


def estimateReadLength(opts):
    readCnt, totalLen = collectReadLens(opts.readsFile, opts.sampleSize)
    if readCnt == 0:
        raise Exception("no reads found in " + opts.readsFile)
    aveLen = totalLen / readCnt
    if aveLen == 0:
        raise Exception("aver length of 0 from " + opts.readsFile)
    if opts.outfile is None:
        writeReadLen(sys.stdout, aveLen)
    else:
        with open(opts.outfile, "w") as fh:
            writeReadLen(fh, aveLen)

estimateReadLength(parseArgs())
