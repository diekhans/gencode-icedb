#!/usr/bin/env python

from __future__ import print_function
import icedbProgSetup  # noqa: F401
import re
import argparse
from pycbio.sys import fileOps
from gencode_icedb.gbffProblemCaseParser import gbffProblemCaseParse, Organism
from gencode_icedb.genbankProblemCasesDb import GenbankProblemCase
# Note: wanted to do this via eutils, however NCBI can't
# query on clone library


def parseArgs():
    desc = """Scan genbank flat files looking for known problem libraries.
    Should scan:
        gbpri*.seq.gz
        gbrod*.seq.gz
        gbest*.seq.gz
    Since this looks for historic problem submissions, this can be run
    once and the output saved.  This detects the following problems:
      - NEDO libraries - sequencing technique that is often missing internal
        portions of RNA.
      - Athersys RAGE library - induced expression library
      - ORESTES library - PCR clones

   Note that Athersys RAGE and ORESTES flagging are a duplication of what is
   done by the UCSC GenBank pipeline.
"""
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('--maxProcess', type=int, default=2,
                        help="maximum number of process to use for parallel parse")
    parser.add_argument('hsTabOut',
                        help="output for human")
    parser.add_argument('mmTabOut',
                        help="output for mouse")
    parser.add_argument('gbffInputs', nargs="*",
                        help="Genbank Flat Files, maybe compressed")
    return parser.parse_args()


class SplitAcc(list):
    "split accssion into (alpha, numeric, version)"
    __slots__ = ("alpha", "numeric", "version")

    def __init__(self, acc):
        parts = re.split("([A-Z]+)([0-9]+)\\.([0-9]+)", acc)
        if len(parts) != 5:
            raise Exception("can't parse accession \"{}\"".format(acc))
        self.alpha = parts[1]
        self.numeric = int(parts[2])
        self.version = int(parts[3])

    def __str__(self):
        return "{}{}.{}".format(self.alpha, self.numeric, self.version)

    def isIncr(self, accSplit):
        """is accSplit numeric part one more than this part and the
        rest the same"""
        return (accSplit.alpha == self.alpha) and (accSplit.numeric == self.numeric + 1) and (accSplit.version == self.version)


class OrgProblemCases(list):
    "collect organism problem cases and convert to accession ranges"

    def __popRange(self, idx):
        reason = self[idx].reason
        startAcc = endAcc = SplitAcc(self[idx].acc)
        idx += 1
        while (idx < len(self)) and (self[idx].reason == reason):
            nextAcc = SplitAcc(self[idx].acc)
            if endAcc.isIncr(nextAcc):
                endAcc = nextAcc
                idx += 1
            else:
                break
        return (GenbankProblemCase(str(startAcc), str(endAcc), reason), idx)

    def writeRanges(self, tabFh):
        self.sort(key=lambda opc: (opc.acc,))
        idx = 0
        while idx < len(self):
            problemCase, idx = self.__popRange(idx)
            fileOps.prRow(tabFh, problemCase)


def collectProblemCases(gbffInputs, maxProcess):
    problemEntries = gbffProblemCaseParse(gbffInputs, maxProcess)
    byOrgProblemCases = {o: OrgProblemCases() for o in Organism}
    for problemEntry in problemEntries:
        byOrgProblemCases[problemEntry.organism].append(problemEntry)
    return byOrgProblemCases


def writeProblemCases(orgProblemCases, tabOut):
    with open(tabOut, "w") as tabFh:
        orgProblemCases.writeRanges(tabFh)


def gbffGetProblemCases(opts):
    byOrgProblemCases = collectProblemCases(opts.gbffInputs, opts.maxProcess)
    writeProblemCases(byOrgProblemCases[Organism.hs], opts.hsTabOut)
    writeProblemCases(byOrgProblemCases[Organism.mm], opts.mmTabOut)


gbffGetProblemCases(parseArgs())
