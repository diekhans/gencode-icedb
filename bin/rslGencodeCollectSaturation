#!/usr/bin/env python

from __future__ import print_function
import icedbProgSetup  # noqa: F401
import argparse
import random
from collections import defaultdict
from pycbio.sys import fileOps
from pycbio.hgbrowser.coords import Coords
from gencode_icedb.rsl.rslModel import sqliteConnect, SjSupportReader
from gencode_icedb.rsl.intronSupportCounter import IntronCoords
from gencode_icedb.rsl.saturation import SaturationCounts


def parseArgs():
    desc = """Collect saturation evidence fir annotated and novel splice sites
    for a chromosome range (window) that are not in GENCODE annotations.
    If an putative intron is not completely in the window into the chromosome,
    it will only be processed if window contains the first bases of the
    intron.  This allows generating contiguous, non-overlapping regions.

    Saturation is compute on a experiment by experiment level.
    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('--testMode', action="store_true", default=False,
                        help="""don't randomize experiments for testing""")
    parser.add_argument('sjDb',
                        help="""splice junction evidence sqlite3 database, a correspond *.sjsup.gz and tabix index file must exist""")
    parser.add_argument('resultsTsv',
                        help="""TSV file for results""")
    parser.add_argument('chromRange',
                        help="""zero-based chromosome range, in the form chr:start-end.""")
    return parser.parse_args()


def inWindow(intron, window):
    return (intron.chromStart >= window.start) and (intron.chromStart < window.end)


def useSjSupport(sjSupp, window):
    return (sjSupp.annotated or (sjSupp.numUniqueMapReads > 0)) and inWindow(sjSupp, window)


class IntronCount(object):
    """counts for a specified intron"""
    def __init__(self, intronCoords, isNovel):
        self.intronCoords = intronCoords
        self.isNovel = isNovel
        self.numExprs = self.numUniqueMapReads = self.numMultiMapReads = 0

    def __str__(self):
        return "{}: novel={} exprs={} uniq={} multi={}".format(self.intronCoords, self.isNovel, self.numExprs, self.numUniqueMapReads, self.numMultiMapReads)

    def addSupport(self, sjSupp):
        self.numUniqueMapReads += sjSupp.numUniqueMapReads
        self.numMultiMapReads += sjSupp.numMultiMapReads


class IntronCounter(dict):
    """indexed by IntronCoords, all introns are defined upfront, both novel and annotated"""
    def __init__(self, window):
        self.window = window

    def __defineIntron(self, sjSupp):
        intronCoords = IntronCoords.fromIntronSupp(sjSupp)
        if intronCoords not in self:
            self[intronCoords] = IntronCount(intronCoords, not sjSupp.annotated)

    def defineIntrons(self, sjSupps):
        for sjSupp in sjSupps:
            if useSjSupport(sjSupp, self.window):
                self.__defineIntron(sjSupp)

    def countIntronSupports(self, sjSupps):
        for sjSupp in sjSupps:
            if useSjSupport(sjSupp, self.window):
                self[IntronCoords.fromIntronSupp(sjSupp)].addSupport(sjSupp)


class CollectSaturation(object):
    def __init__(self, window, sjConn, testMode):
        self.testMode = testMode
        self.intronCounter = IntronCounter(window)
        self.sjSuppByExpr = defaultdict(list)
        sjSupps = self.__loadIntrons(sjConn, window)
        # defines all introns that will be analyzed
        self.intronCounter.defineIntrons(sjSupps)

    def __loadIntrons(self, sjConn, window):
        sjSupps = []
        for sjSupp in SjSupportReader(sjDbConn=sjConn).fetch(window.chrom, window.start, window.end):
            self.sjSuppByExpr[sjSupp.mapping_symid].append(sjSupp)
            sjSupps.append(sjSupp)
        return sjSupps

    def __collectExpr(self, fh, exprCnt, sjSupps):
        self.intronCounter.countIntronSupports(sjSupps)
        saturationCounts = SaturationCounts(exprCnt)
        for sjcnts in self.intronCounter.values():
            saturationCounts.count(sjcnts.isNovel, sjcnts)
        saturationCounts.write(fh)

    def collectByExpr(self, fh):
        """add in support from each experiment and output"""
        SaturationCounts.writeHeader(fh)
        exprCnt = 0
        exprs = list(self.sjSuppByExpr.keys())
        if not self.testMode:
            random.shuffle(exprs)
        for expr in exprs:
            exprCnt += 1
            self.__collectExpr(fh, exprCnt, self.sjSuppByExpr[expr])


def rslGencodeCollectSaturation(opts):
    "entry point"
    genomeCoords = Coords.parse(opts.chromRange)
    sjConn = sqliteConnect(opts.sjDb, readonly=True)
    saturationCollector = CollectSaturation(genomeCoords, sjConn, opts.testMode)

    fileOps.ensureFileDir(opts.resultsTsv)
    resultsTmpTsv = fileOps.atomicTmpFile(opts.resultsTsv)
    with open(resultsTmpTsv, "w") as fh:
        saturationCollector.collectByExpr(fh)

    fileOps.atomicInstall(resultsTmpTsv, opts.resultsTsv)
    if not sjConn.is_closed():  # FIXME: not sure why it is in the is_closed state, maybe lazy open?
        sjConn.close()


rslGencodeCollectSaturation(parseArgs())
