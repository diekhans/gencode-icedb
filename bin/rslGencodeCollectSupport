#!/usr/bin/env python

from __future__ import print_function
import icedbProgSetup  # noqa: F401
import argparse
import csv
import sqlite3
from collections import defaultdict
from pycbio.sys import fileOps
from pycbio.hgdata.hgLite import GencodeAttrsDbTable, GenePredDbTable
from gencode_icedb.general import gencodeDb
from gencode_icedb.general.genome import GenomeReaderFactory
from gencode_icedb.general.transFeatures import IntronFeature
from gencode_icedb.general.annotFeatures import AnnotationGenePredFactory
from gencode_icedb.rsl.rslModel import sqliteConnect, SjSupportReader
from gencode_icedb.rsl.intronSupportCounter import IntronSupportCounter


def parseArgs():
    desc = """Collect splice site evidence for a subset of GENCODE annotations."""
    parser = argparse.ArgumentParser(description=desc)
    GenomeReaderFactory.addCmdOptions(parser)
    parser.add_argument('gencodeDb',
                        help="""GENCODE sqlite3 database from gencodeDbLoad""")
    parser.add_argument('sjDb',
                        help="""splice junction evidence sqlite3 database, a correspond *.sjsup.gz and tabix index file must exist""")
    parser.add_argument('resultsTsv',
                        help="""TSV file for results""")
    parser.add_argument('gencodeIds', nargs='*',
                        help="""GENCODE gene or transcript ids, including versions.  If not are specified, all transcript are processed""")
    return parser.parse_args()


resultsHeader = ("geneId", "geneName", "transcriptId", "transcriptType",
                 "chrom", "intronStart", "intronEnd", "strand", "intronMotif",
                 "numExprs", "numUniqueMapReads", "numMultiMapReads")


class SupportCounter(object):
    def __init__(self, gencodeConn, sjConn, genomeReader):
        self.attrsDbTable = GencodeAttrsDbTable(gencodeConn, gencodeDb.gencode_attrs_table)
        self.annDbTable = GenePredDbTable(gencodeConn, gencodeDb.gencode_ann_table)
        self.sjSupportReader = SjSupportReader(sjDbConn=sjConn)
        self.annFactory = AnnotationGenePredFactory(genomeReader)
        self.genomeReader = genomeReader

    def __getAttrsById(self, gencodeId):
        "try gene, then transcript id"
        attrs = self.attrsDbTable.getByGeneId(gencodeId)
        if len(attrs) > 0:
            return attrs
        attr = self.attrsDbTable.getByTranscriptId(gencodeId)
        if attr is not None:
            return [attr]
        raise Exception("can't find GENCODE gene or transcript with id {}".format(gencodeId))

    def __getTranscripts(self, attrs):
        """return list of transcripts annotations, which would be empty if the annotations
        were on alts that were not aligned"""
        transes = []
        for attr in attrs:
            for gp in self.annDbTable.getByName(attr.transcriptId):
                transes.append(self.annFactory.fromGenePred(gp))
        return transes

    def __getPrimaryTranscript(self, transes):
        "get primary transcript, dropping PAR, alts, etc"
        byChrom = defaultdict(list)
        for trans in transes:
            byChrom[trans.chrom].append(trans)
        chroms = list(byChrom.keys())
        if len(chroms) == 1:
            return byChrom[chroms[0]]
        if "chrY" in chroms:
            # ignored Y
            chroms.remove("chrY")
        # use shortest
        chroms.sort(key=lambda c: len(c))
        return byChrom[chroms[0]]

    def __splitAttrsByTrans(self, attrs):
        attrsByTrans = dict()
        for attr in attrs:
            attrsByTrans[attr.transcriptId] = attr
        return attrsByTrans

    def __getBounds(self, transes):
        start = min([a.chromStart for a in transes])
        end = max([a.chromEnd for a in transes])
        return transes[0].chrom, start, end

    def __sumSupportsByIntron(self, chrom, start, end):
        intronSupportCnts = IntronSupportCounter(self.genomeReader)
        for sjSupp in self.sjSupportReader.fetch(chrom, start, end):
            intronSupportCnts.sumSjSupp(sjSupp)
        return intronSupportCnts

    def __sumSupportForTranses(self, transes, attrsByTrans):
        """Sums support by introns for SJ in the range, so transcripts should be a locus,
        either transcripts in one gene locus or one transcript.  Collecting all upfront
        prevents multiple queries for shared introns."""
        chrom, start, end = self.__getBounds(transes)
        return self.__sumSupportsByIntron(chrom, start, end)

    def __reportTransIntronSupport(self, trans, transAttrs, intronFeat, intronSupportCnts, resultsWriter):
        intron, sjCounts = intronSupportCnts.getIntronFeatCounts(intronFeat)
        resultsWriter.writerow([transAttrs.geneId, transAttrs.geneName,
                                transAttrs.transcriptId,
                                transAttrs.transcriptType,
                                intron.chrom, intron.chromStart, intronFeat.chromEnd,
                                intron.strand, intron.intronMotif,
                                sjCounts.numExprs,
                                sjCounts.numUniqueMapReads,
                                sjCounts.numMultiMapReads])

    def __reportTranscriptSupport(self, trans, transAttrs, intronSupportCnts, resultsWriter):
        for feat in trans.features:
            if isinstance(feat, IntronFeature):
                self.__reportTransIntronSupport(trans, transAttrs, feat, intronSupportCnts, resultsWriter)

    def __collectTranscriptsSupport(self, transes, attrsByTrans, resultsWriter):
        intronSupportCnts = self.__sumSupportForTranses(transes, resultsWriter)
        for trans in transes:
            self.__reportTranscriptSupport(trans, attrsByTrans[trans.rnaName], intronSupportCnts, resultsWriter)

    def __collectSupportId(self, gencodeId, resultsWriter):
        attrs = self.__getAttrsById(gencodeId)
        transes = self.__getTranscripts(attrs)
        if len(transes) > 0:
            self.__collectTranscriptsSupport(self.__getPrimaryTranscript(transes),
                                             self.__splitAttrsByTrans(attrs),
                                             resultsWriter)

    def collectSupport(self, gencodeIds, resultsWriter):
        if len(gencodeIds) == 0:
            gencodeIds = self.attrsDbTable.getAllGeneIds()
        resultsWriter.writerow(resultsHeader)
        for gencodeId in gencodeIds:
            self.__collectSupportId(gencodeId, resultsWriter)


def rslGencodeCollectSupport(opts):
    "entry point"
    genomeReader = GenomeReaderFactory.factoryFromCmdOptions(opts).obtain()

    gencodeConn = sqlite3.connect(opts.gencodeDb)  # FIXME: switch to APSW read-only
    sjConn = sqliteConnect(opts.sjDb, readonly=True)
    supportCounter = SupportCounter(gencodeConn, sjConn, genomeReader)

    fileOps.ensureFileDir(opts.resultsTsv)
    resultsTmpTsv = fileOps.atomicTmpFile(opts.resultsTsv)
    with open(resultsTmpTsv, "w") as fh:
        supportCounter.collectSupport(opts.gencodeIds, csv.writer(fh, dialect=csv.excel_tab,
                                                                  lineterminator='\n'))
    fileOps.atomicInstall(resultsTmpTsv, opts.resultsTsv)
    gencodeConn.close()
    if not sjConn.is_closed():  # FIXME: not sure why it is in the is_closed state, maybe lazy open?
        sjConn.close()


rslGencodeCollectSupport(parseArgs())
