#!/usr/bin/env python

from __future__ import print_function
import icedbProgSetup  # noqa: F401
import argparse
import csv
import sqlite3
from collections import defaultdict, namedtuple
from pycbio.sys import fileOps
from pycbio.hgdata.hgLite import GencodeAttrsDbTable, GenePredDbTable
from gencode_icedb.general import gencodeDb
from gencode_icedb.general.genome import GenomeReaderFactory
from gencode_icedb.general.transFeatures import IntronFeature
from gencode_icedb.general.annotFeatures import AnnotationGenePredFactory
from gencode_icedb.rsl.rslModel import sqliteConnect, SjSupportReader


def parseArgs():
    desc = """Collect splice site evidence for some GENCODE annotations.
    Designed to be run as a batch job."""
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('--genomeSeqs',
                        help="""Genome sequence twobit file to obtain splice sites""")
    parser.add_argument('--mockGenomeSeqs',
                        help="""Genome sequence TSV for mock reader for testing. This will be used if genomeSeqs is not specified or does not exist.""")
    parser.add_argument('--updateMockGenomeSeqs',
                        help="""update mock genome seqs.""")
    parser.add_argument('--forceMockGenomeSeqs',
                        help="""force using mock genome seqs, even if twobit exists""")
    parser.add_argument('gencodeDb',
                        help="""GENCODE sqlite3 database from gencodeDbLoad""")
    parser.add_argument('sjDb',
                        help="""splice junction evidence sqlite3 database, a correspond *.sjsup.gz and tabix index file must exist""")
    parser.add_argument('resultsTsv',
                        help="""TSV file for results""")
    parser.add_argument('gencodeIds', nargs='*',
                        help="""GENCODE gene or transcript ids, including versions.  If not are specified, all transcript are processed""")
    return parser.parse_args()


resultsHeader = ("geneId", "geneName", "transcriptId", "transcriptType",
                 "chrom", "intronStart", "intronEnd", "strand", "intronMotif",
                 "numUniqueMapReads", "numMultiMapReads")


class IntronCoords(namedtuple("Intron", ("chrom", "chromStart", "chromEnd",
                                         "strand"))):
    @staticmethod
    def fromSjSupport(sjSupp):
        return IntronCoords(sjSupp.chrom, sjSupp.chromStart, sjSupp.chromEnd, sjSupp.strand)

    @staticmethod
    def fromIntronFeat(intronFeat):
        transFeat = intronFeat.transcript
        return IntronCoords(transFeat.chrom, intronFeat.chromStart, intronFeat.chromEnd, transFeat.rnaStrand)


class SjCounts(object):
    __slots__ = ("intronMotif", "numUniqueMapReads", "numMultiMapReads")

    def __init__(self, intronMotif):
        self.intronMotif = intronMotif
        self.numUniqueMapReads = self.numMultiMapReads = 0

    def __str__(self):
        return "{} {} {}".format(self.intronMotif, self.numUniqueMapReads, self.numMultiMapReads)

    def sum(self, cnts):
        "can sum with SjCounts or SjSupport objects"
        self.numUniqueMapReads += cnts.numUniqueMapReads
        self.numMultiMapReads += cnts.numMultiMapReads


class SupportCounter(object):
    def __init__(self, gencodeConn, sjConn, genomeReader):
        self.attrsDbTable = GencodeAttrsDbTable(gencodeConn, gencodeDb.gencode_attrs_table)
        self.annDbTable = GenePredDbTable(gencodeConn, gencodeDb.gencode_ann_table)
        self.sjSupportReader = SjSupportReader(sjDbConn=sjConn)
        self.annFactory = AnnotationGenePredFactory(genomeReader)

    def __getAttrsById(self, gencodeId):
        "try gene, then transcript id"
        attrs = self.attrsDbTable.getByGeneId(gencodeId)
        if len(attrs) > 0:
            return attrs
        attr = self.attrsDbTable.getByTranscriptId(gencodeId)
        if attr is not None:
            return [attr]
        raise Exception("can't find GENCODE gene or transcript with id {}".format(gencodeId))

    def __getTranscripts(self, attrs):
        """return list of transcripts annotations, which would be empty if the annotations
        were on alts that were not aligned"""
        transes = []
        for attr in attrs:
            for gp in self.annDbTable.getByName(attr.transcriptId):
                transes.append(self.annFactory.fromGenePred(gp))
        return transes

    def __getPrimaryTranscript(self, transes):
        "get primary transcript, dropping PAR, alts, etc"
        byChrom = defaultdict(list)
        for trans in transes:
            byChrom[trans.chrom].append(trans)
        chroms = list(byChrom.keys())
        if len(chroms) == 1:
            return byChrom[chroms[0]]
        if "chrY" in chroms:
            # ignored Y
            chroms.remove("chrY")
        # use shortest
        chroms.sort(key=lambda c: len(c))
        return chroms[0]

    def __splitAttrsByTrans(self, attrs):
        attrsByTrans = dict()
        for attr in attrs:
            attrsByTrans[attr.transcriptId] = attr
        return attrsByTrans

    def __getBounds(self, transes):
        start = min([a.chromStart for a in transes])
        end = max([a.chromEnd for a in transes])
        return transes[0].chrom, start, end

    def __sumSupport(self, byIntronSjSupp, sjSupp):
        intron = IntronCoords.fromSjSupport(sjSupp)
        cnts = byIntronSjSupp.get(intron)
        if cnts is None:
            byIntronSjSupp[intron] = cnts = SjCounts(sjSupp.intronMotif)
        cnts.sum(sjSupp)

    def __sumSupportsByIntron(self, chrom, start, end):
        byIntronSjSupp = dict()
        for sjSupp in self.sjSupportReader.query(chrom, start, end):
            self.__sumSupport(byIntronSjSupp, sjSupp)
        return byIntronSjSupp

    def __sumSupportForRange(self, transes, attrsByTrans):
        """Sums support by introns for SJ in the range, so transcripts should be a locus,
        either transcripts in one gene locus or one transcript.  Collecting all upfront
        prevents multiple queries for shared introns."""
        chrom, start, end = self.__getBounds(transes)
        return self.__sumSupportsByIntron(chrom, start, end)

    def __makeZeroSjSupp(self, intronFeat):
        if intronFeat.donorSeq is not None:
            intronMotif = "{}/{}".format(intronFeat.donorSeq, intronFeat.acceptorSeq)
        else:
            intronMotif = "##/##"
        return SjCounts(intronMotif)

    def __reportTransIntronSupport(self, trans, transAttrs, intronFeat, byIntronSjSupp, resultsWriter):
        sjSupp = byIntronSjSupp.get(IntronCoords.fromIntronFeat(intronFeat))
        if sjSupp is None:
            sjSupp = self.__makeZeroSjSupp(intronFeat)
        resultsWriter.writerow([transAttrs.geneId, transAttrs.geneName,
                                transAttrs.transcriptId,
                                transAttrs.transcriptType,
                                intronFeat.transcript.chrom,
                                intronFeat.chromStart, intronFeat.chromEnd,
                                intronFeat.transcript.rnaStrand, sjSupp.intronMotif,
                                sjSupp.numUniqueMapReads,
                                sjSupp.numMultiMapReads])

    def __reportTranscriptSupport(self, trans, transAttrs, byIntronSjSupp, resultsWriter):
        for feat in trans.features:
            if isinstance(feat, IntronFeature):
                self.__reportTransIntronSupport(trans, transAttrs, feat, byIntronSjSupp, resultsWriter)

    def __collectTranscriptsSupport(self, transes, attrsByTrans, resultsWriter):
        byIntronSjSupp = self.__sumSupportForRange(transes, resultsWriter)
        for trans in transes:
            self.__reportTranscriptSupport(trans, attrsByTrans[trans.rnaName], byIntronSjSupp, resultsWriter)

    def __collectSupportId(self, gencodeId, resultsWriter):
        attrs = self.__getAttrsById(gencodeId)
        transes = self.__getTranscripts(attrs)
        if transes is not None:
            self.__collectTranscriptsSupport(self.__getPrimaryTranscript(transes),
                                             self.__splitAttrsByTrans(attrs),
                                             resultsWriter)

    def collectSupport(self, gencodeIds, resultsWriter):
        if len(gencodeIds) == 0:
            gencodeIds = self.attrsDbTable.getAllGeneIds()
        resultsWriter.writerow(resultsHeader)
        for gencodeId in gencodeIds:
            self.__collectSupportId(gencodeId, resultsWriter)


def rslGencodeCollectSupport(opts):
    "main function"
    # this will check sanity of options
    genomeReaderFactory = GenomeReaderFactory(opts.genomeSeqs, opts.mockGenomeSeqs,
                                              opts.updateMockGenomeSeqs,
                                              opts.forceMockGenomeSeqs)
    genomeReader = genomeReaderFactory.obtain()

    gencodeConn = sqlite3.connect(opts.gencodeDb)  # FIXME: switch to APSW read-only
    sjConn = sqliteConnect(opts.sjDb, readonly=True)
    supportCounter = SupportCounter(gencodeConn, sjConn, genomeReader)

    fileOps.ensureFileDir(opts.resultsTsv)
    resultsTmpTsv = fileOps.atomicTmpFile(opts.resultsTsv)
    with open(resultsTmpTsv, "w") as fh:
        supportCounter.collectSupport(opts.gencodeIds, csv.writer(fh, dialect=csv.excel_tab,
                                                                  lineterminator='\n'))
    fileOps.atomicInstall(resultsTmpTsv, opts.resultsTsv)
    gencodeConn.close()
    if not sjConn.is_closed():  # FIXME: not sure why it is in the is_closed state, maybe lazy open?
        sjConn.close()


rslGencodeCollectSupport(parseArgs())
