#!/usr/bin/env python

from __future__ import print_function
import icedbProgSetup  # noqa: F401
import sys
import argparse
import pipettor
from pycbio.sys import fileOps, loggingOps
from gencode_icedb.rsl.rslModel import sqliteConnect, sqliteClose
from gencode_icedb.rsl.gencodeIntronEvid import IntronSupportLevel, intronEvidSupportLevel
from gencode_icedb.rsl.supportAnalysis import intronSupportReader, intronSupportAlreadyProcessed, SupportTrackColors

def parseArgs():
    desc = """Create a BED of introns support"""
    parser = argparse.ArgumentParser(description=desc)
    loggingOps.addCmdOptions(parser)
    parser.add_argument('--htmlColors', action="store_true", default=False,
                        help="print colors in  HTML format for use in documentation, then exit")
    parser.add_argument("--level", action="append",
                        choices=[str(l) for l in IntronSupportLevel],
                        help="level to include, maybe repeated")
    parser.add_argument("--symLevelName", action="store_true", default=False,
                        help="""include the symbolic level in the name rather than the support counts""")
    parser.add_argument('dataType', choices=("support", "novel"),
                        help="type of database")
    parser.add_argument('intronEvidDb',
                        help="support or novel database")
    parser.add_argument('bedOut',
                        help="output BED file")
    opts = parser.parse_args()
    loggingOps.setupFromCmd(opts, sys.argv[0])
    if opts.level is not None:
        opts.level = frozenset([IntronSupportLevel(l) for l in opts.level])
    else:
        opts.level = frozenset(list(IntronSupportLevel))
    return opts


class BedMaker(object):
    def __init__(self, dataType, symLevelName, levels):
        self.isNovelDb = (dataType == "novel")
        self.symLevelName = symLevelName
        self.reported = set()   # don't output dups due to multiple transcripts
        self.levels = levels

    @staticmethod
    def __evidStrand(evid):
        if (evid.strand is not None) and (evid.strand not in ('?', '.')):
            return evid.strand
        else:
            return '+'  # something valid

    def __evidName(self, evid, level):
        # FIXME: symLevelName is a hack around not having a per-intron level db
        if self.symLevelName:
            return "{} {} ({}, {})".format(evid.intronMotif, str(level), evid.numUniqueMapReads, evid.numMultiMapReads)
        else:
            return "{} ({}, {})".format(evid.intronMotif, evid.numUniqueMapReads, evid.numMultiMapReads)

    def __shouldReport(self, supp, level):
        # don't count no unique for none:
        if self.isNovelDb and (level == IntronSupportLevel.NONE):
            return False
        if intronSupportAlreadyProcessed(supp, self.reported):
            return False
        if level not in self.levels:
            return False
        # don't report weak novel
        return (not self.isNovelDb) or (level > IntronSupportLevel.WEAK)

    def __writeBedRec(self, supp, bedFh):
        level = intronEvidSupportLevel(supp.numUniqueMapReads)
        if self.__shouldReport(supp, level):
            fileOps.prRowv(bedFh, supp.chrom, supp.intronStart, supp.intronEnd,
                           self.__evidName(supp, level), 0, self.__evidStrand(supp),
                           supp.intronStart, supp.intronEnd,
                           SupportTrackColors.supportLevelColor(level).toRgb8Str())

    def writeBed(self, bedFh):
        for rec in intronSupportReader(self.isNovelDb):
            self.__writeBedRec(rec, bedFh)


def rslIntronSuppBed(opts):
    if opts.htmlColors:
        SupportTrackColors.printHtml()
        sys.exit(0)
    bedMaker = BedMaker(opts.dataType, opts.symLevelName, opts.level)
    conn = sqliteConnect(opts.intronEvidDb, readonly=True)
    # sort for use in
    with pipettor.Popen(["sort", "-k1,1", "-k2,2n", "-k3,3n"], "w", stdout=opts.bedOut) as bedFh:
        bedMaker.writeBed(bedFh)
    sqliteClose(conn)


rslIntronSuppBed(parseArgs())
