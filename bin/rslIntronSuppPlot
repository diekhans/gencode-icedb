#!/usr/bin/env python

from __future__ import print_function
import icedbProgSetup  # noqa: F401
import sys
import argparse
import logging
from pycbio.sys import loggingOps
from gencode_icedb.rsl.rslModel import sqliteConnect, sqliteClose, GencodeSupport, GencodeNovel
from collections import defaultdict
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

logger = None


def parseArgs():
    desc = """Create density plots of plots of intron supporting evidence,
    either known or novel"""
    parser = argparse.ArgumentParser(description=desc)
    loggingOps.addCmdOptions(parser)
    parser.add_argument('--readCntBucketSize', type=int, default=10,
                        help="number of reads are bucked by this amount")
    parser.add_argument('dataType', choices=("support", "novel"),
                        help="support or novel database, type determined by header")
    parser.add_argument('intronEvidDb',
                        help="support or novel database, type determined by header")
    parser.add_argument('plotOut',
                        help="output plot file, defaults to pdf")
    opts = parser.parse_args()
    loggingOps.setupFromCmd(opts, sys.argv[0])
    global logger
    logger = logging.getLogger()
    return opts


def isPseudo(suppRec):
    # FIXME: switch to using functions now in CCDS tree
    return (suppRec.transcriptType.find("pseudogene") >= 0) and (suppRec.transcriptType != "polymorphic_pseudogene")


class IntronEvidData(object):
    def __init__(self, dataType, readCntBucketSize):
        self.readCntBucketSize = readCntBucketSize
        self.isNovel = (dataType == "novel")
        self.intronsByReadCnt = None

    def __keep(self, rec):
        return self.isNovel or (not isPseudo(rec))

    def __logIntronsByReadCnt(self):
        logger.debug("readCnt\tnumIntrons")
        for readCntBucket in sorted(self.intronsByReadCnt.keys()):
            logger.debug("{}\t{}".format(readCntBucket * self.readCntBucketSize, self.intronsByReadCnt[readCntBucket]))

    def load(self):
        self.intronsByReadCnt = defaultdict(int)
        if self.isNovel:
            ormCls = GencodeNovel
        else:
            ormCls = GencodeSupport
        for rec in ormCls.select():
            if self.__keep(rec):
                self.intronsByReadCnt[rec.numUniqueMapReads / self.readCntBucketSize] += 1
        if logger.isEnabledFor(logging.DEBUG):
            self.__logIntronsByReadCnt()

    def __countDictToList(self, intronsByReadCnt):
        intronCnts = []
        suppCnts = []
        for readCntBucket in intronsByReadCnt.keys():
            intronCnts.append(intronsByReadCnt[readCntBucket])
            suppCnts.append(readCntBucket * self.readCntBucketSize)
        return intronCnts, suppCnts

    def plot(self, plotOut, uselog=False):
        intronCnts, suppCnts = self.__countDictToList(self.intronsByReadCnt)
        color = "b"

        if self.isNovel:
            xlabel = "Novel Introns"
        else:
            xlabel = "GENCODE Introns"
        ylabel = "Unique mapped supporting reads"
        plt.interactive(False)
        if uselog:
            plt.xscale('log')
            xlabel += " (log)"
            plt.yscale('log')
            ylabel += " (log)"
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        plt.scatter(intronCnts, suppCnts, color=color, rasterized=True)
        plt.savefig(plotOut)
        plt.show()


def rslIntronSuppPlot(opts):
    intronEvidData = IntronEvidData(opts.dataType, opts.readCntBucketSize)
    conn = sqliteConnect(opts.intronEvidDb, readonly=True)
    intronEvidData.load()
    sqliteClose(conn)
    intronEvidData.plot(opts.plotOut, uselog=True)


rslIntronSuppPlot(parseArgs())
