#!/usr/bin/env python

from __future__ import print_function
import icedbProgSetup  # noqa: F401
import sys
import argparse
import sqlite3
from pycbio.sys import fileOps, loggingOps, mathOps
from pycbio.hgdata.hgLite import GencodeTranscriptSourceDbTable, GencodeTranscriptionSupportLevelDbTable
from gencode_icedb.general import gencodeDb
from gencode_icedb.rsl.rslModel import sqliteConnect, sqliteClose
from gencode_icedb.rsl.gencodeIntronEvid import IntronSupportLevel, intronEvidSupportLevel
from gencode_icedb.rsl.supportAnalysis import intronSupportReader
from gencode.data.gencodeGenes import BioType, bioTypesCoding, bioTypesNonCoding, sourceToExtendedMethod

# FIXME: move to analysis repo


def parseArgs():
    desc = """Create statistics on transcript support"""
    parser = argparse.ArgumentParser(description=desc)
    loggingOps.addCmdOptions(parser)
    parser.add_argument('--chrom',
                        help="limit to chrom (for testing)")
    parser.add_argument('gencodeDb',
                        help="GENCODE database")
    parser.add_argument('intronEvidDb',
                        help="support database")
    parser.add_argument('outPrefix',
                        help="prefix for statistics output files")
    opts = parser.parse_args()
    loggingOps.setupFromCmd(opts, sys.argv[0])
    return opts


class Trans(object):
    def __init__(self, geneId, transcriptId, bioType):
        self.geneId = geneId
        self.transcriptId = transcriptId
        self.bioType = bioType
        self.source = None
        self.tsl = None
        self.introns = []
        self.intronLevels = []

    @property
    def chrom(self):
        return self.introns[0].chrom

    def finish(self):
        self.intronLevels = [intronEvidSupportLevel(intron.numMultiMapReads) for intron in self.introns]

    def countLevels(self):
        levelCnts = len(IntronSupportLevel) * [0]
        for intronLevel in self.intronLevels:
            levelCnts[intronLevel.value] += 1
        return levelCnts

    def fullSupportLevel(self):
        "finds lowest level any intron, which is the full transcript support level"
        levelCnts = self.countLevels()
        for level in IntronSupportLevel:
            if levelCnts[level.value] > 0:
                return level


class IntronEvidData(object):
    "data linked to GENCODE transcripts"
    def __init__(self):
        self.chroms = set()
        self.byTransIds = {}

    def __obtainTransInfo(self, rec):
        trans = self.byTransIds.get(rec.transcriptId)
        if trans is None:
            trans = self.byTransIds[rec.transcriptId] = Trans(rec.geneId, rec.transcriptId, rec.transcriptType)
        return trans

    def __loadRec(self, rec):
        self.chroms.add(rec.chrom)
        self.__obtainTransInfo(rec).introns.append(rec)

    def load(self, chrom):
        for rec in intronSupportReader(False, chrom):
            self.__loadRec(rec)
        for transInfo in self.byTransIds.values():
            transInfo.finish()

    def loadGencodeSource(self, gencodeDbConn):
        dbTable = GencodeTranscriptSourceDbTable(gencodeDbConn, gencodeDb.gencode_transcript_source_table)
        for rec in dbTable.queryAll():
            trans = self.byTransIds.get(rec.transcriptId)
            if trans is not None:
                trans.source = sourceToExtendedMethod(rec.source)

    def loadGencodeSupportLevel(self, gencodeDbConn):
        dbTable = GencodeTranscriptionSupportLevelDbTable(gencodeDbConn, gencodeDb.gencode_transcription_support_level_table)
        for rec in dbTable.queryAll():
            trans = self.byTransIds.get(rec.transcriptId)
            if trans is not None:
                trans.tsl = rec.level

    ##
    # per-transcript support
    ##

    def __reportTranscriptSupport(self, fh):
        fileOps.prRow(fh, ["transcriptId", "numIntrons"]
                      + [l for l in reversed(IntronSupportLevel)])
        for transId in sorted(self.byTransIds.keys()):
            trans = self.byTransIds[transId]
            fileOps.prRow(fh, [trans.transcriptId, len(trans.introns)]
                          + list(reversed(trans.countLevels())))

    def reportTranscriptSupport(self, transSuppTsv):
        with open(transSuppTsv, "w") as fh:
            self.__reportTranscriptSupport(fh)

    ##
    # full transcript support stats
    ##

    def __cntTranscriptsFullStats(self, transFilter):
        levelTotals = [0 for l in IntronSupportLevel]
        for trans in self.byTransIds.values():
            if transFilter(trans):
                levelTotals[trans.fullSupportLevel().value] += 1
        return levelTotals

    def __reportTranscriptTypeFullStats(self, transType, subfilter, subtype, transFilter, fh):
        levelTotals = self.__cntTranscriptsFullStats(transFilter)
        transCnt = sum(levelTotals)
        fileOps.prRow(fh, [transType, subfilter, subtype]
                      + list(reversed(levelTotals))
                      + [mathOps.calcFmtFreq(c, transCnt) for c in reversed(levelTotals)])

    @staticmethod
    def __allFilter(trans):
        return True

    @staticmethod
    def __codingFilter(trans):
        return BioType(trans.bioType) in bioTypesCoding

    @staticmethod
    def __nonCodingFilter(trans):
        return BioType(trans.bioType) in bioTypesNonCoding

    def __reportTranscriptTypeFullStatsByTsl(self, fh):
        for tsl in xrange(1, 6):
            self.__reportTranscriptTypeFullStats("all", "tsl", tsl, lambda trans: trans.tsl == tsl and self.__allFilter(trans), fh)
        for tsl in xrange(1, 6):
            self.__reportTranscriptTypeFullStats("coding", "tsl", tsl, lambda trans: trans.tsl == tsl and self.__codingFilter(trans), fh)
        for tsl in xrange(1, 6):
            self.__reportTranscriptTypeFullStats("non-coding", "tsl", tsl, lambda trans: trans.tsl == tsl and self.__nonCodingFilter(trans), fh)

    def __reportTranscriptTypeFullStatsByChrom(self, fh):
        chroms = sorted(self.chroms, key=lambda c: (len(c), c))
        for chrom in chroms:
            self.__reportTranscriptTypeFullStats("all", "chrom", chrom, lambda trans: trans.chrom == chrom and self.__allFilter(trans), fh)
        for chrom in chroms:
            self.__reportTranscriptTypeFullStats("coding", "chrom", chrom, lambda trans: trans.chrom == chrom and self.__codingFilter(trans), fh)
        for chrom in chroms:
            self.__reportTranscriptTypeFullStats("non-coding", "chrom", chrom, lambda trans: trans.chrom == chrom and self.__nonCodingFilter(trans), fh)

    def __reportTranscriptFullSupportStats(self, fh):
        fileOps.prRow(fh, ["type", "subfilter", "subtype"]
                      + ["{}_cnt".format(l) for l in reversed(IntronSupportLevel)]
                      + ["{}_freq".format(l) for l in reversed(IntronSupportLevel)])
        self.__reportTranscriptTypeFullStats("all", "none", "all", self.__allFilter, fh)
        self.__reportTranscriptTypeFullStats("coding", "none", "all", self.__codingFilter, fh)
        self.__reportTranscriptTypeFullStats("non-coding", "none", "all", self.__nonCodingFilter, fh)
        self.__reportTranscriptTypeFullStatsByTsl(fh)
        self.__reportTranscriptTypeFullStatsByChrom(fh)

    def reportTranscriptFullSupportStats(self, transSuppStatsTsv):
        with open(transSuppStatsTsv, "w") as fh:
            self.__reportTranscriptFullSupportStats(fh)


def rslIntronSuppStats(opts):
    intronEvidData = IntronEvidData()
    conn = sqliteConnect(opts.intronEvidDb, readonly=True)
    intronEvidData.load(opts.chrom)
    sqliteClose(conn)
    fileOps.ensureFileDir(opts.outPrefix)
    gencodeDbConn = sqlite3.connect(opts.gencodeDb)
    intronEvidData.loadGencodeSource(gencodeDbConn)
    intronEvidData.loadGencodeSupportLevel(gencodeDbConn)
    gencodeDbConn.close()
    intronEvidData.reportTranscriptSupport("{}trans-support.tsv".format(opts.outPrefix))
    intronEvidData.reportTranscriptFullSupportStats("{}trans-full-support-stats.tsv".format(opts.outPrefix))

rslIntronSuppStats(parseArgs())
