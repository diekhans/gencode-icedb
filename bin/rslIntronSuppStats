#!/usr/bin/env python

from __future__ import print_function
import icedbProgSetup  # noqa: F401
import sys
import argparse
from collections import defaultdict
from pycbio.sys import fileOps, loggingOps, mathOps
from gencode_icedb.rsl.rslModel import sqliteConnect, sqliteClose
from gencode_icedb.rsl.gencodeIntronEvid import IntronSupportLevel, intronEvidSupportLevel
from gencode_icedb.rsl.supportAnalysis import intronSupportReader
# FIXME: split into intron and transcript programs

def parseArgs():
    desc = """Create statistics on intron supporting evidence"""
    parser = argparse.ArgumentParser(description=desc)
    loggingOps.addCmdOptions(parser)
    parser.add_argument('dataType', choices=("support", "novel"),
                        help="type of database")
    parser.add_argument('intronEvidDb',
                        help="support or novel database")
    parser.add_argument('outPrefix',
                        help="prefix for statistics output files")
    opts = parser.parse_args()
    loggingOps.setupFromCmd(opts, sys.argv[0])
    return opts


class IntronEvidData(object):
    "data linked to GENCODE transcripts"
    def __init__(self, dataType):
        self.isNovelDb = (dataType == "novel")
        self.byGeneTrans = None
        if not self.isNovelDb:
            self.byGeneTrans = defaultdict(lambda: defaultdict(list))  # by-gene, by-transcript
        self.introns = {}  # dup gene/trans dropped

    def __loadRec(self, rec):
        if not self.isNovelDb:
            self.byGeneTrans[rec.geneId][rec.transcriptId].append(rec)
        # only keeps one, so not double counted
        self.introns[(rec.intronStart, rec.intronEnd, rec.strand)] = rec

    def load(self):
        for rec in intronSupportReader(self.isNovelDb):
            self.__loadRec(rec)

    def __cntSupportLevels(self):
        uniqCnts = defaultdict(int)
        bothCnts = defaultdict(int)
        for intron in self.introns.values():
            ulevel = intronEvidSupportLevel(intron.numUniqueMapReads)
            mlevel = intronEvidSupportLevel(intron.numMultiMapReads)
            uniqCnts[ulevel] += 1
            bothCnts[(ulevel, mlevel)] += 1
        return uniqCnts, bothCnts

    def __reportUniqSupportLevels(self, uniqCnts, fh):
        total = len(self.introns)
        fileOps.prRowv(fh, "uniqLevel", "count", "rate")
        for ulevel in reversed(IntronSupportLevel):
            fileOps.prRowv(fh, ulevel, uniqCnts[ulevel], mathOps.calcFmtFreq(uniqCnts[ulevel], total))
        fileOps.prRowv(fh, "total", total, mathOps.calcFmtFreq(uniqCnts[ulevel], total))

    def __reportBothSupportLevels(self, bothCnts, fh):
        total = len(self.introns)
        fileOps.prRowv(fh, "uniqLevel", "multiLevel", "count", "rate")
        for ulevel in reversed(IntronSupportLevel):
            for mlevel in reversed(IntronSupportLevel):
                key = (ulevel, mlevel)
                fileOps.prRowv(fh, ulevel, mlevel, bothCnts[key], mathOps.calcFmtFreq(bothCnts[key], total))
        fileOps.prRowv(fh, "total", "total", total, mathOps.calcFmtFreq(total, total))

    def reportSupportLevels(self, uniqTsv, bothTsv):
        uniqCnts, bothCnts = self.__cntSupportLevels()
        with open(uniqTsv, "w") as fh:
            self.__reportUniqSupportLevels(uniqCnts, fh)
        with open(bothTsv, "w") as fh:
            self.__reportBothSupportLevels(bothCnts, fh)

    supportedIntronBins = (1.0, 0.80, 0.50, 0.00001, 0.0)

    def __getBinIdx(self, fracIntrons):
        for iBin in xrange(len(self.supportedIntronBins)):
            if fracIntrons >= self.supportedIntronBins[iBin]:
                return iBin
        assert False, "bin not found for {}".format(fracIntrons)

    def __cntTranscriptLevels(self, transIntrons):
        intronLevels = [intronEvidSupportLevel(intron.numMultiMapReads) for intron in transIntrons]
        levelCnts = len(IntronSupportLevel) * [0]
        for intronLevel in intronLevels:
            for ilev in xrange(intronLevel.value, -1, -1):
                levelCnts[ilev] += 1
        return levelCnts

    def __cntTranscript(self, transIntrons, cntMatrix):
        levelCnts = self.__cntTranscriptLevels(transIntrons)
        numIntrons = float(len(transIntrons))
        for iLevel in xrange(len(levelCnts)):
            iBin = self.__getBinIdx(levelCnts[iLevel] / numIntrons)
            cntMatrix[iBin][iLevel] += 0 if levelCnts[iLevel] == 0 else 1

    def __cntTranscripts(self):
        # columns are min level, rows are fraction of introns
        transCnt = 0
        cntMatrix = [[0 for l in IntronSupportLevel] for b in self.supportedIntronBins]
        for geneTrans in self.byGeneTrans.values():
            for transIntrons in geneTrans.values():
                self.__cntTranscript(transIntrons, cntMatrix)
                transCnt += 1
        return transCnt, cntMatrix

    def __reportTranscriptSupport(self, fh):
        fileOps.prRow(fh, ["fracIntrons"]
                      + ["{}_cnt".format(l) for l in reversed(IntronSupportLevel)]
                      + ["{}_freq".format(l) for l in reversed(IntronSupportLevel)])
        transCnt, cntMatrix = self.__cntTranscripts()
        for iBin in xrange(len(self.supportedIntronBins)):
            fileOps.prRow(fh, [self.supportedIntronBins[iBin]]
                          + list(reversed(cntMatrix[iBin]))
                          + [mathOps.calcFmtFreq(c, transCnt) for c in reversed(cntMatrix[iBin])])

    def reportTranscriptSupport(self, transSuppTsv):
        with open(transSuppTsv, "w") as fh:
            self.__reportTranscriptSupport(fh)


def rslIntronSuppStats(opts):
    intronEvidData = IntronEvidData(opts.dataType)
    conn = sqliteConnect(opts.intronEvidDb, readonly=True)
    intronEvidData.load()
    sqliteClose(conn)
    fileOps.ensureFileDir(opts.outPrefix)
    intronEvidData.reportSupportLevels("{}uniq-support.tsv".format(opts.outPrefix),
                                       "{}both-support.tsv".format(opts.outPrefix))
    if not intronEvidData.isNovelDb:
        intronEvidData.reportTranscriptSupport("{}trans-support.tsv".format(opts.outPrefix))


rslIntronSuppStats(parseArgs())
