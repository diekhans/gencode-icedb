#!/usr/bin/env python

from __future__ import print_function
import icedbProgSetup  # noqa: F401
import sys
import argparse
import sqlite3
from collections import defaultdict
from pycbio.sys import fileOps, loggingOps, mathOps
from pycbio.hgdata.hgLite import GencodeTranscriptSourceDbTable, GencodeTranscriptionSupportLevelDbTable
from gencode_icedb.general import gencodeDb
from gencode_icedb.rsl.rslModel import sqliteConnect, sqliteClose
from gencode_icedb.rsl.gencodeIntronEvid import IntronSupportLevel, intronEvidSupportLevel
from gencode_icedb.rsl.supportAnalysis import intronSupportReader
from gencode.data.gencodeGenes import BioType, bioTypesCoding, bioTypesNonCoding, sourceToExtendedMethod

# FIXME: split into intron and transcript programs
# FIXME: move to analysis repo


def parseArgs():
    desc = """Create statistics on intron supporting evidence"""
    parser = argparse.ArgumentParser(description=desc)
    loggingOps.addCmdOptions(parser)
    parser.add_argument('--chrom',
                        help="limit to chrom (for testing)")
    parser.add_argument('dataType', choices=("support", "novel"),
                        help="type of database")
    parser.add_argument('gencodeDb',
                        help="GENCODE database")
    parser.add_argument('intronEvidDb',
                        help="support or novel database")
    parser.add_argument('outPrefix',
                        help="prefix for statistics output files")
    opts = parser.parse_args()
    loggingOps.setupFromCmd(opts, sys.argv[0])
    return opts


class Trans(object):
    def __init__(self, geneId, transcriptId, bioType):
        self.geneId = geneId
        self.transcriptId = transcriptId
        self.bioType = bioType
        self.source = None
        self.tsl = None
        self.introns = []
        self.intronLevels = []

    @property
    def chrom(self):
        return self.introns[0].chrom
        
    def finish(self):
        self.intronLevels = [intronEvidSupportLevel(intron.numMultiMapReads) for intron in self.introns]

    def countLevels(self):
        levelCnts = len(IntronSupportLevel) * [0]
        for intronLevel in self.intronLevels:
            levelCnts[intronLevel.value] += 1
        return levelCnts

    def fullSupportLevel(self):
        "finds lowest level any intron, which is the full transcript support level"
        levelCnts = self.countLevels()
        for level in IntronSupportLevel:
            if levelCnts[level.value] > 0:
                return level


class IntronEvidData(object):
    "data linked to GENCODE transcripts"
    def __init__(self, dataType):
        self.isNovelDb = (dataType == "novel")
        self.introns = {}  # dup gene/trans dropped
        self.chroms = set()
        self.byTransIds = None
        if not self.isNovelDb:
            self.byTransIds = {}

    def __obtainTransInfo(self, rec):
        trans = self.byTransIds.get(rec.transcriptId)
        if trans is None:
            trans = self.byTransIds[rec.transcriptId] = Trans(rec.geneId, rec.transcriptId, rec.transcriptType)
        return trans

    def __loadRec(self, rec):
        # only keeps one, so not double counted
        self.introns[(rec.intronStart, rec.intronEnd, rec.strand)] = rec
        self.chroms.add(rec.chrom)
        if not self.isNovelDb:
            self.__obtainTransInfo(rec).introns.append(rec)

    def load(self, chrom):
        for rec in intronSupportReader(self.isNovelDb, chrom):
            self.__loadRec(rec)
        if not self.isNovelDb:
            for transInfo in self.byTransIds.values():
                transInfo.finish()

    def loadGencodeSource(self, gencodeDbConn):
        dbTable = GencodeTranscriptSourceDbTable(gencodeDbConn, gencodeDb.gencode_transcript_source_table)
        for rec in dbTable.queryAll():
            trans = self.byTransIds.get(rec.transcriptId)
            if trans is not None:
                trans.source = sourceToExtendedMethod(rec.source)

    def loadGencodeSupportLevel(self, gencodeDbConn):
        dbTable = GencodeTranscriptionSupportLevelDbTable(gencodeDbConn, gencodeDb.gencode_transcription_support_level_table)
        for rec in dbTable.queryAll():
            trans = self.byTransIds.get(rec.transcriptId)
            if trans is not None:
                trans.tsl = rec.level
        
    ##
    # Uniq support levels
    ##

    def __cntUniqSupportLevels(self):
        uniqCnts = defaultdict(int)
        for intron in self.introns.values():
            ulevel = intronEvidSupportLevel(intron.numUniqueMapReads)
            uniqCnts[ulevel] += 1
        return uniqCnts

    def __reportUniqSupportLevels(self, fh):
        uniqCnts = self.__cntUniqSupportLevels()
        total = len(self.introns)
        fileOps.prRowv(fh, "uniqLevel", "count", "rate")
        for ulevel in reversed(IntronSupportLevel):
            fileOps.prRowv(fh, ulevel, uniqCnts[ulevel], mathOps.calcFmtFreq(uniqCnts[ulevel], total))
        fileOps.prRowv(fh, "total", total, mathOps.calcFmtFreq(uniqCnts[ulevel], total))

    def reportUniqSupportLevels(self, uniqTsv):
        with open(uniqTsv, "w") as fh:
            self.__reportUniqSupportLevels(fh)

    ##
    # Uniq and multi support levels
    ##

    def __cntBothSupportLevels(self):
        bothCnts = defaultdict(int)
        for intron in self.introns.values():
            ulevel = intronEvidSupportLevel(intron.numUniqueMapReads)
            mlevel = intronEvidSupportLevel(intron.numMultiMapReads)
            bothCnts[(ulevel, mlevel)] += 1
        return bothCnts

    def __reportBothSupportLevels(self, fh):
        bothCnts = self.__cntBothSupportLevels()
        total = len(self.introns)
        fileOps.prRowv(fh, "uniqLevel", "multiLevel", "count", "rate")
        for ulevel in reversed(IntronSupportLevel):
            for mlevel in reversed(IntronSupportLevel):
                key = (ulevel, mlevel)
                fileOps.prRowv(fh, ulevel, mlevel, bothCnts[key], mathOps.calcFmtFreq(bothCnts[key], total))
        fileOps.prRowv(fh, "total", "total", total, mathOps.calcFmtFreq(total, total))

    def reportBothSupportLevels(self, bothTsv):
        with open(bothTsv, "w") as fh:
            self.__reportBothSupportLevels(fh)

    ##
    # per-transcript support
    ##

    def __reportTranscriptSupport(self, fh):
        fileOps.prRow(fh, ["transcriptId", "numIntrons"]
                      + [l for l in reversed(IntronSupportLevel)])
        for transId in sorted(self.byTransIds.keys()):
            trans = self.byTransIds[transId]
            fileOps.prRow(fh, [trans.transcriptId, len(trans.introns)]
                          + list(reversed(trans.countLevels())))

    def reportTranscriptSupport(self, transSuppTsv):
        with open(transSuppTsv, "w") as fh:
            self.__reportTranscriptSupport(fh)

    ##
    # full transcript support stats
    ##

    def __cntTranscriptsFullStats(self, transFilter):
        levelTotals = [0 for l in IntronSupportLevel]
        for trans in self.byTransIds.values():
            if transFilter(trans):
                levelTotals[trans.fullSupportLevel().value] += 1
        return levelTotals

    def __reportTranscriptTypeFullStats(self, transType, subtype, transFilter, fh):
        levelTotals = self.__cntTranscriptsFullStats(transFilter)
        transCnt = sum(levelTotals)
        fileOps.prRow(fh, [transType, subtype]
                      + list(reversed(levelTotals))
                      + [mathOps.calcFmtFreq(c, transCnt) for c in reversed(levelTotals)])

    @staticmethod
    def __allFilter(trans):
        return True

    @staticmethod
    def __codingFilter(trans):
        return BioType(trans.bioType) in bioTypesCoding

    @staticmethod
    def __nonCodingFilter(trans):
        return BioType(trans.bioType) in bioTypesNonCoding

    def __reportTranscriptTypeFullStatsByTsl(self, fh):
        for tsl in xrange(0, 6):
            self.__reportTranscriptTypeFullStats("All/tsl", tsl, lambda trans: trans.tsl == tsl and self.__allFilter(trans), fh)
        for tsl in xrange(0, 6):
            self.__reportTranscriptTypeFullStats("Coding/tsl", tsl, lambda trans: trans.tsl == tsl and self.__codingFilter(trans), fh)
        for tsl in xrange(0, 6):
            self.__reportTranscriptTypeFullStats("Non-coding/tsl", tsl, lambda trans: trans.tsl == tsl and self.__nonCodingFilter(trans), fh)

    def __reportTranscriptTypeFullStatsByChrom(self, fh):
        chroms = sorted(self.chroms, key=lambda c: (len(c), c))
        for chrom in chroms:
            self.__reportTranscriptTypeFullStats("All/chrom", chrom, lambda trans: trans.chrom == chrom and self.__allFilter(trans), fh)
        for chrom in chroms:
            self.__reportTranscriptTypeFullStats("Coding/chrom", chrom, lambda trans: trans.chrom == chrom and self.__codingFilter(trans), fh)
        for chrom in chroms:
            self.__reportTranscriptTypeFullStats("Non-coding/chron", chrom, lambda trans: trans.chrom == chrom and self.__nonCodingFilter(trans), fh)
            
    def __reportTranscriptFullSupportStats(self, fh):
        fileOps.prRow(fh, ["type", "subtype"]
                      + ["{}_cnt".format(l) for l in reversed(IntronSupportLevel)]
                      + ["{}_freq".format(l) for l in reversed(IntronSupportLevel)])
        self.__reportTranscriptTypeFullStats("All", "all", self.__allFilter, fh)
        self.__reportTranscriptTypeFullStats("Coding", "all", self.__codingFilter, fh)
        self.__reportTranscriptTypeFullStats("Non-coding", "all", self.__nonCodingFilter, fh)
        self.__reportTranscriptTypeFullStatsByTsl(fh)
        self.__reportTranscriptTypeFullStatsByChrom(fh)

    def reportTranscriptFullSupportStats(self, transSuppStatsTsv):
        with open(transSuppStatsTsv, "w") as fh:
            self.__reportTranscriptFullSupportStats(fh)


def rslIntronSuppStats(opts):
    intronEvidData = IntronEvidData(opts.dataType)
    conn = sqliteConnect(opts.intronEvidDb, readonly=True)
    intronEvidData.load(opts.chrom)
    sqliteClose(conn)
    fileOps.ensureFileDir(opts.outPrefix)
    intronEvidData.reportUniqSupportLevels("{}uniq-support-stats.tsv".format(opts.outPrefix))
    intronEvidData.reportBothSupportLevels("{}both-support-stats.tsv".format(opts.outPrefix))
    if not intronEvidData.isNovelDb:
        gencodeDbConn = sqlite3.connect(opts.gencodeDb)
        intronEvidData.loadGencodeSource(gencodeDbConn)
        intronEvidData.loadGencodeSupportLevel(gencodeDbConn)
        gencodeDbConn.close()
        intronEvidData.reportTranscriptSupport("{}trans-support.tsv".format(opts.outPrefix))
        intronEvidData.reportTranscriptFullSupportStats("{}trans-full-support-stats.tsv".format(opts.outPrefix))


rslIntronSuppStats(parseArgs())
