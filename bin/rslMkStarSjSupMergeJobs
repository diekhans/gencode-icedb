#!/usr/bin/env python

from __future__ import print_function
import icedbProgSetup  # noqa: F401
import os
import sys
import argparse
import logging
import glob
from pycbio.sys import loggingOps, fileOps


filesPerJob = 25
maxParasolAddJobCmd = 1420
rslStarSjSupMergeJob = os.path.join(icedbProgSetup.rootDir, "bin", "rslStarSjSupMergeJob")

def parseArgs():
    desc = """generate a series of parasol batches to merge splice split
    splice junction files."""
    parser = argparse.ArgumentParser(description=desc)
    loggingOps.addCmdOptions(parser)
    parser.add_argument('mergeWorkDir',
                        help="""Directory for doing split and merge.  Chrom splits should be in mergeWorkDir/byChrom""")
    opts = parser.parse_args()
    loggingOps.setupFromCmd(opts, sys.argv[0])
    return opts

def getByChromSplits(byChromDir):
    "return list of split sjsup files, in chrom sorted order"
    sjsupSplits = []
    for chromDir in glob.glob(os.path.join(byChromDir, "*")):
        for sjsupSplit in glob.glob(os.path.join(chromDir, "*.sjsup")):
            sjsupSplits.append(sjsupSplit)
    if len(sjsupSplits) == 0:
        exit("Error: no sjsup fies found in under: {}".format(byChromDir))
    return sjsupSplits

def calcParaAddJobOverhead(mergeBatchDir):
    """calculate the overhead of for a parasol addJob2 internal message"""
    # overhead includs username current directory, the string "/dev/null" twiice
    # and the path to the results file. This is a guess
    return 200 + len(os.getcwd()) + len(mergeBatchDir)


def writeMergeBatchJob(sjsupSplits, mergeBatchFh, mergeBatchDir, cmdOverhead, iSplit, iJob, sjsupMerges):
    mergeJobOut = os.path.join(mergeBatchDir, "{:03}.sjsup".format(iJob))
    cmd = [rslStarSjSupMergeJob, mergeJobOut]
    cmdLen = cmdOverhead + sum(map(lambda w: len(w)+1, cmd))  # include space separator
    fileCnt = 0
    while (fileCnt < filesPerJob) and (iSplit < len(sjsupSplits)):
        argLen = len(sjsupSplits[iSplit]) + 1
        if cmdLen + argLen > maxParasolAddJobCmd:
            break  # parasol max command length exceeded
        cmd.append(sjsupSplits[iSplit])
        cmdLen += argLen
        iSplit += 1
        fileCnt += 1
        
    if fileCnt == 0:
        raise Exception("no file added to job, maybe paths exceed parasol max")
    print(" ".join(cmd), file=mergeBatchFh)
    sjsupMerges.append(mergeJobOut)
    return iSplit


def writeMergeBatch(sjsupSplits, mergeBatchFh, mergeBatchDir):
    cmdOverhead = calcParaAddJobOverhead(mergeBatchDir)
    sjsupMerges = []
    iSplit = 0
    iJob = 0
    while iSplit < len(sjsupSplits):
        iSplit = writeMergeBatchJob(sjsupSplits, mergeBatchFh, mergeBatchDir, cmdOverhead, iSplit, iJob, sjsupMerges)
        iJob += 1
    return sjsupMerges

def mkMergeBatch(sjsupSplits, mergeBatchFile, mergeBatchDir):
    """for a list of input files, generate a merge batch, return list of merge
    output"""
    with open(mergeBatchFile, "w") as mergeBatchFh:
        return writeMergeBatch(sjsupSplits, mergeBatchFh, mergeBatchDir)

def rslMkStarSjOutSplits(opts):
    byChromDir = os.path.join(opts.mergeWorkDir, "byChrom")
    sjsupSplits = getByChromSplits(byChromDir)
    mergeBatchNum = 0
    while len(sjsupSplits) > 1:
        mergeBatchDir = os.path.join(opts.mergeWorkDir, "{:03}.merged".format(mergeBatchNum))
        mergeBatchFile = os.path.join(opts.mergeWorkDir, "{:03}.merge.jobs".format(mergeBatchNum))
        sjsupSplits = mkMergeBatch(sjsupSplits, mergeBatchFile, mergeBatchDir)
        mergeBatchNum += 1

rslMkStarSjOutSplits(parseArgs())
