#!/usr/bin/env python
"""
Obtain cDNA alignments from an Ensembl database.
"""
from __future__ import print_function
import icedbProgSetup  # noqa: F401
import sys
import argparse
from pycbio.hgdata import hgDb
from pycbio.hgdata.psl import Psl, PslBlock, reverseCoords
from pycbio.hgdata.cigar import ExonerateCigar, OP_ALIGNED, OP_TINSERT, OP_TDELETE
from pycbio.hgdata.hgLite import PslDbTable
from pycbio.sys import dbOps, fileOps, loggingOps
from pycbio.ncbi.assembly import AssemblyReport
import eutils.client
import MySQLdb
import MySQLdb.cursors
import apsw
import logging


ensDbHost = "ensembldb.ensembl.org"
ensDbPort = 5306
ensDbUser = "anonymous"


def parseArgs():
    desc = """Fetch cDNA alignments from Ensembl and load as PSLs in evidence
    sqllite3 database.

    The Ensembl alignments don't include the poly-A and lack the lengths,
    The length of cDNA sequences are obtained from either the UCSC browser
    database or NCBI eutils API.
"""
    parser = argparse.ArgumentParser(description=desc)
    loggingOps.addCmdOptions(parser)
    parser.add_argument('--hgFixedDb', default="hgFixed",
                        help="""hgFixed database to use to get sizes""")
    parser.add_argument('--limit', type=int,
                        help="""limit on query resuts, used for tests""")
    parser.add_argument('--accverList',
                        help="""file with list of accession/versions to process, used for testing.""")
    parser.add_argument('--ensChrom', action="append", dest="ensChroms",
                        help="""Restrict to this chromosome (Ensembl conventions), maybe repeated, used for testing.""")
    parser.add_argument('ensemblCDnaDb',
                        help="""Ensembl cDNA database to use""")
    parser.add_argument('assemblyReport',
                        help="""NCBI assembly report for mapping chromosome names""")
    parser.add_argument('sqliteDb',
                        help="""database to load alignments into""")
    parser.add_argument('table',
                        help="""table to load alignments""")
    opts = parser.parse_args()
    loggingOps.setupFromCmd(opts, sys.argv[0])
    return opts


ensCDnaAlnQuery = """SELECT
    daf.hit_name, daf.hit_strand, daf.hit_start, daf.hit_end,
    sr.name, sr.length, daf.seq_region_strand, daf.seq_region_start, daf.seq_region_end,
    daf.cigar_line
  FROM
    dna_align_feature daf, seq_region sr, external_db ed, transcript_supporting_feature tsf
  WHERE
    ((daf.seq_region_id = sr.seq_region_id)
     AND (daf.external_db_id = ed.external_db_id)
     AND (ed.db_name = "EMBL")
     AND (daf.dna_align_feature_id = tsf.feature_id)
     AND (tsf.feature_type = "dna_align_feature"))"""


class CDnaSizeFinder(object):
    "work around the fact that Ensembl doesn't have cDNA sizes"
    def __init__(self, hgFixedDb):
        self.hgFixedConn = hgDb.connect(hgFixedDb)
        self.eclient = eutils.client.Client()

    def __getSizeUcsc(self, accver):
        acc, ver = accver.split('.')
        cur = self.hgFixedConn.cursor()
        try:
            sql = """select size from gbSeq where (acc = %s) and (version = %s)"""
            cur.execute(sql, (acc, int(ver)))
            row = cur.fetchone()
            if row is None:
                return None
            else:
                return row[0]
        finally:
            cur.close()

    def __getSizeEutils(self, accver):
        esr = self.eclient.esearch(db='nuccore', term=accver)
        if len(esr.ids) == 0:
            return None
        if len(esr.ids) > 1:
            raise Exception("multiple results return for eutil query for `{}'".format(accver))
        efr = self.eclient.efetch(db='nuccore', id=esr.ids[0])
        return efr.gbseqs[0].length

    def getSize(self, accver):
        size = self.__getSizeUcsc(accver)
        if size is None:
            size = self.__getSizeEutils(accver)
        return size


def buildCDnaQuery(limit, accverSubset, ensChromsSubset):
    sql = ensCDnaAlnQuery
    sqlArgs = []
    if accverSubset is not None:
        sql += " AND (daf.hit_name in ({}))".format(",".join(len(accverSubset) * ["%s"]))
        sqlArgs += accverSubset
    if ensChromsSubset is not None:
        sql += " AND (sr.name in ({}))".format(",".join(len(ensChromsSubset) * ["%s"]))
        sqlArgs += ensChromsSubset
    if limit is not None:
        sql += " LIMIT {}".format(limit)
    return sql, sqlArgs


def ensemblCDnaQuery(ensemblCDnaDb, limit=None, accverSubset=None, ensChromsSubset=None):
    "generator of cDNA alignments from Ensembl"
    conn = MySQLdb.Connect(host=ensDbHost, port=ensDbPort, user=ensDbUser,
                           db=ensemblCDnaDb, cursorclass=MySQLdb.cursors.DictCursor)
    sql, sqlArgs = buildCDnaQuery(limit, accverSubset, ensChromsSubset)
    try:
        cur = conn.cursor()
        cur.execute(sql, sqlArgs)
        for row in cur:
            yield row
    finally:
        conn.close()


def processCigarMatch(psl, size, qNext, tNext):
    blk = PslBlock(psl, qNext, tNext, size)
    psl.blocks.append(blk)
    psl.blockCount += 1
    psl.match += size
    return (qNext + size, tNext + size)


def processCigarInsert(psl, size, tNext):
    psl.tNumInsert += 1
    psl.tBaseInsert += size
    return tNext + size


def processCigarDelete(psl, size, qNext):
    psl.qNumInsert += 1
    psl.qBaseInsert += size
    return qNext + size


def pslFromCigar(qName, qSize, qStart, qEnd, qStrand, tName, tSize, tStart, tEnd, tStrand, cigarStr):
    "create a PSL from an Ensembl-style cigar formatted alignment"
    cigar = ExonerateCigar(cigarStr)
    psl = Psl()
    psl.qName = qName
    psl.qSize = qSize
    psl.qStart = qStart
    psl.qEnd = qEnd
    psl.tName = tName
    psl.tSize = tSize
    psl.tStart = tStart
    psl.tEnd = tEnd
    psl.strand = qStrand + tStrand

    qNext = qStart
    qBlkEnd = qEnd
    if qStrand == '-':
        qNext, qBlkEnd = reverseCoords(qNext, qBlkEnd, qSize)
    tNext = tStart
    tBlkEnd = tEnd
    if tStrand == '-':
        tNext, tBlkEnd = reverseCoords(tNext, tBlkEnd, tSize)

    for op in cigar:
        if op.code == OP_ALIGNED:
            qNext, tNext = processCigarMatch(psl, op.count, qNext, tNext)
        elif op.code == OP_TINSERT:
            tNext = processCigarInsert(psl, op.count, tNext)
        elif op.code == OP_TDELETE:
            qNext = processCigarDelete(psl, op.count, qNext)
        else:
            raise Exception("invalid CIGAR op {} in {}".format(op, cigar))

    if qNext != qBlkEnd:
        raise Exception("CIGAR length does not match aligned query range: {} {}".format(qName, cigar))
    if tNext != tBlkEnd:
        raise Exception("CIGAR length does not match aligned target range: {} {}".format(qName, cigar))
    assert(len(psl.blocks) == psl.blockCount)
    if psl.getTStrand() == '-':
        psl = psl.reverseComplement()
    psl.strand = psl.strand[0]   # BLAT convention
    return psl


def orientToStrand(orient):
    return '-' if orient < 0 else '+'


def pslFromEnsembl(row, qSize, tName, tSize):
    return pslFromCigar(row["hit_name"], qSize, row["hit_start"] - 1, row["hit_end"], orientToStrand(row["hit_strand"]),
                        tName, tSize, row["seq_region_start"] - 1, row["seq_region_end"], orientToStrand(row["seq_region_strand"]),
                        row["cigar_line"])


class EnsemblCDnaConverter(object):
    def __init__(self, cDnaSizeFinder, asmReport):
        self.cDnaSizeFinder = cDnaSizeFinder
        self.asmReport = asmReport
        self.reportedUnmappedChrs = set()

    def __findChromInfo(self, row):
        # unplaced use GenBank acccession, some case use sequenceName with CHR_
        # prefix, which are patches embedded in full chroms, and are ignored
        chrom = row["name"]
        chromInfo = self.asmReport.bySequenceName.get(chrom)
        if chromInfo is None:
            chromInfo = self.asmReport.byGenBankAccn.get(chrom)
        if chromInfo is None:
            if (chrom not in self.reportedUnmappedChrs) and (not chrom.startswith("CHR_")):
                print("Note: Ensembl chromosome `{}' not in assembly info".format(chrom), file=sys.stderr)
                self.reportedUnmappedChrs.add(chrom)
            return None
        if chromInfo.ucscStyleName is None:
            if chrom not in self.reportedUnmappedChrs:
                print("Note: Ensembl chromosome `{}' is not mapped to an UCSC chromosome".format(row["name"]), file=sys.stderr)
                self.reportedUnmappedChrs.add(chrom)
            return None
        return chromInfo

    def __convertToPsl(self, row):
        "return psl or None"
        qSize = self.cDnaSizeFinder.getSize(row["hit_name"])
        if qSize is None:
            print("Note: UCSC and eutils esearch can't find `{}'".format(row["hit_name"]), file=sys.stderr)
            return None
        chromInfo = self.__findChromInfo(row)
        if chromInfo is None:
            return None
        return pslFromEnsembl(row, qSize, chromInfo.ucscStyleName, chromInfo.sequenceLength)

    def ensemblCDnasToPsls(self, ensemblCDnaDb, limit, accverSubset, ensChromsSubset):
        psls = []
        for row in ensemblCDnaQuery(ensemblCDnaDb, limit, accverSubset, ensChromsSubset):
            logging.getLogger().debug("Ensembl cDNA row: {}".format(row))
            psl = self.__convertToPsl(row)
            if psl is not None:
                psls.append(psl)
        psls.sort(key=lambda p: (p.tName, p.tStart, p.tEnd))
        return psls


def cdnaEnsemblAligns(opts):
    "main function"
    converter = EnsemblCDnaConverter(CDnaSizeFinder(opts.hgFixedDb),
                                     AssemblyReport(opts.assemblyReport))
    accverSubset = fileOps.readFileLines(opts.accverList) if opts.accverList is not None else None
    psls = converter.ensemblCDnasToPsls(opts.ensemblCDnaDb, opts.limit, accverSubset, opts.ensChroms)
    conn = apsw.APSWDatabase(opts.sqliteDb)
    pslDbTable = PslDbTable(conn, opts.table, create=True)
    pslDbTable.loads(psls)
    conn.close()


dbOps.mySqlSetErrorOnWarn()
cdnaEnsemblAligns(parseArgs())
